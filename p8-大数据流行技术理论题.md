

###### **1、maven是什么及其生命周期**

```
maven是一个项目管理工具，可以对项目的整个生命周期进行管理，并且可以对项目的依赖jar包进行管理。
Maven的生命周期包括：清理、编译、测试、打包、安装、部署,对应命令如下：
清理 mvn clean 将会删除 target 目录及内容
编译 mvn compile 将java文件编译为 class 文件输出到 target 目录下
测试 mvn test 执行单元测试类
打包 mvn package 把项目打包到项目的target目录
安装 mvn install 包含package，且将项目打包安装到本地仓库
部署 mvn deploy 包含install，且将项目上传到远程仓库
```

###### **2、maven的jar包冲突，如何解决**

```
maven自带两种方式：
路径就近原则：依赖传递过来的路径近的优先。
优先声明原则：在 pom 文件定义依赖，先声明的依赖为准。

手动配置两种方式：
排除法：通过exclusion标签排除依赖
锁定版本：通过dependencyManagement 直接锁定版本

```

###### **3、通用mapper的特点有哪些**

```
1、mapper.xml基本没有内容，避免了原生mybatis中的大量SQL
2、可移植性好，不惧数据库软件的切换
3、通用mapper使用代码生成插件生成代码，生成的代码量比原生mybatis少很多
4、通用mapper中的批量操作可以直接设置条件，无需自己手写代码
```

###### **4、mybatis的运行原理**

```
1.加载核心配置文件
2.创建 sqlSessionFactory 
3.创建 sqlSession
4.由 sqlSession 调执行器
5.输入参数
6.执行 sql
7.返回结果

```

###### **5、简述mybatis中 #{}和${}的区别**

```
#{}:占位符，使用 #{} 格式的语法会导致 MyBatis 创建 PreparedStatement 参数并安全地设置参数（就像使用 ? 一样）；   
${}:连接符，不对参数做任何解析，直接拼接 sql 语句，相当于 statment，有 sql 注入风险，一般需要使用 group by ,order by 必须使用列名时才使用;

```

###### **6、String 和 StringBuffer,StringBuilder 的区别是什么**

```
相同点：三个类都是处理字符串的类；
不同点：
String 中的对象是不可变的，也就可以理解为常量
StringBuffer 对方法加了同步锁，所以是线程安全的，效率比较低，适合多线程。
StringBuilder 并没有对方法进行加同步锁，线程不安全的，效率高适合单线程。

```

###### **7、文件上传三要素**

```
1、表单提交方式：post
2、表单的enctype属性：multipart/form-data
3、表单必须有文件上传项：file
```

###### 8、Spring中有哪些设计模式

```
工厂模式：用来创建对象的实例；
单例模式：Bean 默认为单例模式。
代理模式：Spring 的 AOP 功能用到了 JDK 和 CGLIB 动态代理技术
模板方法模式：用来解决代码重复的问题
适配器模式：使用在AOP中
```

###### **9、什么是IOC？什么是DI？二者有什么关系**

```
1、IOC: 控制反转，把对象创建交给spring进行配置
2、DI: 依赖注入，向类里面的属性中设置值
3、关系：依赖注入不能单独存在，需要在ioc基础之上完成操作

```

###### **10、列举出 springmvc 的常用注解，至少 4 个及其作用**

```
@controller 主要负责处理前端控制器(DispatcherServlet )发过来的请求 
@RequestMapping 是一个用来处理请求地址映射的注解 
@RequestParam 是从 Request 里获取参数值 
@Service 用于标注业务层 
@Autowired，自动装配 
@Resource 通过 name 属性去匹配 bean 
@ResponseBody ，会直接返回 json 或者 xml 数据。
@RequestBody 接收json或xml数据


```

###### **11、重载重写的区别**

```
重载： 发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，与方法的修饰符和返回值无关 
重写： 发生在父子类中，方法名.参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类
```

###### **12、jquery常用的方法有哪些**

```
val():获取value的值
text():获取标签之间的文本内容
html():获取标签之间的所有内容
prop("属性名","属性值")：为标签的某个属性赋值
```

###### 13、String中常用的方法有哪些(最少5个)

```
split()：把字符串分割成字符串数组
indexOf()：从指定字符提取索引位置
trim()：去除字符串两端空格
replace()：替换
hashCode()：返回此字符串的哈希码
subString()：截取字符串
equals()：比较两个字符串的值
length()：获取字符串的长度
valueOf()：转换为字符串
concat()：将指定字符串连接到此字符串的结尾
```

###### 14、如何解决get和post乱码问题

```
解决post请求乱码：我们可以在web.xml里边配置一个CharacterEncodingFilter 过滤器。设置为utf-8。
解决get请求乱码有两种方法个：
	1）修改tomcat配置文件添加编码和工程编码一致；
	2) 另一种方法对请求参数进行重新编码；
```

###### 15、左外连接和右外连接的区别

```
左连接以左表为主，其结果会将左表所有的查询信息列出，而右表只列出ON后条件与左表满足的部分
右连接以右表为主，其结果会将右表所有的查询信息列出，而左表只列出ON后条件与右表满足的部分
```

###### 16、HashMap底层原理

```
在jdk1.8中 底层是数组 链表 红黑树实现
在Hashmap中，初始化长度为16，当用put方法存储数据时，传入key及value值，此时将key值进行hash运算0后的hash值作为entry（嗯吹）键值对在数组的索引位置，确定位置之后，首先判断该位置是否为空，如果为空，就将entry值放在该位置，否则将entry以链表的方式存在数组中，当链表长度超过8位之后，会将链表转换为红黑树继续存储entry
```

###### 17、创建线程的几种不同的方式

```
继承 Thread 类
实现 Runnable 接口
应用程序可以使用 Executor 框架来创建线程池
```

###### 18、有关线程sleep和wait的区别

```
wait方法是线程等待，调用这个方法之后，线程进入等待状态，只有等待通知notify或者notifyAll才会继续执行，会释放锁，释放cpu资源。
sleep线程睡眠，让当前线程休眠，此时线程处于阻塞的状态，时间到了之后，线程继续向下执行，不会释放锁，不会解除cpu占用

```

###### 19、线程都有哪些方法（至少5个）

```
wait(): 线程等待
sleep():线程休眠
yield():线程让步
join(): 线程插队
interrupt():线程中断
notify(): 唤醒线程
notifyAll(): 唤醒所有线程
```

###### 20、ArryList与LinkedList的区别

```
LinkedList基于链表的数据结构；ArrayList基于动态数组的数据结构
LinkedList 在插入和删除数据时效率更高，ArrayList 查询效率更高；
```

###### 21、介绍下ConcurrentHashMap

```
ConcurrentHashMap是线程安全的HashMap，内部采用了的"分段锁"策略，它的主干是个Segment数组，通过继承ReentrantLock 来进行加锁。所以每次锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。一个Segment就是一个子哈希表，默认有16 个 Segment。所以理论上，只要它们的操作分别分布在不同的 Segment 上，最多可以同时支持 16 个线程并发写
```



###### 22、说说你对Redis的理解

```
1、Redis是基于C语言开发的key-value形式的nosql数据库，数据存储在内存中，有string hash list set zset 五种数据类型
2、由于数据存储在内存中，为防止服务器宕机数据丢失，支持RDB和 AOF 俩种持久化方式。
RDB: 默认开启，把内存快照的形式把内存中的数据持久化到本地磁盘文件。
AOF: 默认不开启，需要手动开启，设置appendonly 值为yes；aof是把写或删除的操作（命令）日志以追加的方式保存磁盘文件
```



###### 23、Redis缓存的使用场景

```
Redis经常被作为缓存来使用，当我们第一次查询时，redis缓存中没有数据，所以会先去数据库查询，并将查询到的数据，保存到redis中一份，当我第二次或者之后再查询时，直接从redis查询，减轻了数据库的压力，提高了查询效率，增强了用户体验
```

###### 24、Redis缓存雪崩

```
缓存雪崩造成因素有2个：
1、Redis服务器宕机
2、同一时间Redis中缓存的数据大量过期，原本该去缓存查询的大量请求，有缓存出现问题，全都去数据查询，导致数据压力太大，系统崩溃。
解决方案：
可以给key的过期时间+随机数（让key的过期时间尽可能的分散）
```

###### 25、Redis缓存穿透

```
所谓穿透，就是访问了一个缓存中不存在，数据库里也不存在的key，那么相当于每次请求都会直接访问数据库。
如何解决呢？
1、对查询结果为空的数据也进行缓存，当再次查询不存在的数据，直接在Redis中返回即可。
考虑到数据可能并不是一直不存在，可以将过期时间设置的时间短一点，避免数据更新后的数据缓存中查不到。
2、布隆过滤器：在系统启动时，针对全量数据进行布隆过滤器映射；
当客户端发起查询请求时，先通过布隆过滤器过滤，布隆过滤器说查询的数据不存在，那一定不存在，可以将缓存穿透的查询大概率的进行拦截。
```

###### 26、在项目中怎么使用Spring如何整合Redis

```
Spring Data Redis简化了Redis编程，直接在Spring环境中使用即可。它提供了操作Redis的抽象层（RedisTemplate)，拿来即用，使用户摆脱了基础设施的困扰
使用步骤：
创建Maven项目
添加依赖：spring-data-redis
添加连接池依赖：commons-pool2
在spring-redis.xml中配置连接信息
在service层通过@Autowired注入RedisTemplate依赖
```

###### 27、RabbitMQ的五种工作模式

```
简单模式，工作模式，发布订阅模式，路由模式，主题模式
```

###### 28、如何保证MQ消息不丢失？如何解决数据丢失的问题

```
1、持久化设置、 设置交换机持久化、队列持久化、 消息持久化
2、ACK确认机制、是消费端消费完成要通知服务端，服务端才把消息从内存删除。
3、设置集群镜像模式
4、消息补偿机制、根据状态字段进行补偿，发送完成和接收完成都要对状态做出变更，定时任务检超时没有接收的或者接收失败的，重新发送
```

###### 29、如何避免消息重复投递或重复消费

```
1、在消息生产时，MQ 内部针对每条生产者发送的消息生成一个 消息id，作为去重的依据，避免重复的消息进入队列；
2、在消息消费时，要求消息体中必须要有一个业务id作为去重的依据，避免同一条消息被重复消费。

```

###### 30、说下Linux常用命令（至少5个）

```
cd：进入某个目录 
pwd：查看当前目录
ls：查看当前目录下有哪些文件
mkdir：创建一个目录 
cp：复制文件     
mv： 文件移动 
rm -rf：递归强制删除  
tar -xzvf：解压缩 
tail -200f 文件名：动态输出日志最后200行
kill -9 进程pid：强制杀死进程
ps -ef|grep tomcat：查看tomcat进程pid

```

